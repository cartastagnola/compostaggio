////////////////////////////////////////////////////////////////////////////
//
//  This file is part of RTIMULib
//
//  Copyright (c) 2014-2015, richards-tech, LLC
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to use,
//  copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
//  Software, and to permit persons to whom the Software is furnished to do so,
//  subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
//  PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
//  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
//  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


#include "RTIMULib.h"
#include <fstream>
#include <iostream>

FILE * pLogTot;
FILE * pLogEuroc;

struct 
IMUtiming
{
    int sampleCount;
    int sampleRate;
    uint64_t rateTimer;
    uint64_t displayTimer;
    uint64_t now;
};

IMUtiming initIMUtiming()
{
	IMUtiming times;
	times.sampleCount = 0;
	times.sampleRate = 0;
	// set up for rate timer
	times.rateTimer = times.displayTimer = RTMath::currentUSecsSinceEpoch();

	return(times);
}


RTIMU* initIMU()
{
    //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
    //  Or, you can create the .ini in some other directory by using:
    //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
    //  where <directory path> is the path to where the .ini file is to be loaded/saved

    RTIMUSettings *settings = new RTIMUSettings("RTIMULib");

    RTIMU *imu = RTIMU::createIMU(settings);

    if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
        printf("No IMU found\n");
        exit(1);
    }

    //  This is an opportunity to manually override any settings before the call IMUInit
    //  set up IMU

    imu->IMUInit();

    //  this is a convenient place to change fusion parameters

    imu->setSlerpPower(0.02);
    imu->setGyroEnable(true);
    imu->setAccelEnable(true);
    imu->setCompassEnable(true);

    return(imu);
}


void recordIMUdata(RTIMU* imu, IMUtiming * times)
{

	// output logging data
	pLogTot = fopen("pLogTot.txt", "a");
	fprintf(pLogTot, "\n\ninit\n");
	fclose (pLogTot);

	pLogEuroc = fopen("pLogEuroc.txt", "a");
	fprintf(pLogEuroc, "\n\n#timestamp [ns],w_RS_S_x [rad s^-1],w_RS_S_y [rad s^-1],w_RS_S_z [rad s^-1],a_RS_S_x [m s^-2],a_RS_S_y [m s^-2],a_RS_S_z [m s^-2]\n");
	fclose (pLogEuroc);

	while (1) {
		//  poll at the rate recommended by the IMU
		usleep(imu->IMUGetPollInterval() * 1000);

		//printf("poll interal %u \n", imu->IMUGetPollInterval());
		// the calue of the pool intervell is 3

		while (imu->IMURead()) {
			RTIMU_DATA imuData = imu->getIMUData();
			times->sampleCount++;

			times->now = RTMath::currentUSecsSinceEpoch();

			//  display 100 times per second
			if ((times->now - times->displayTimer) > 10000) {
				////////////// logging /////////////////
				printf("Sample rate %d: %s\n", times->sampleRate, RTMath::displayDegrees("", imuData.fusionPose));

				// complete log file
				pLogTot = fopen("pLogTot.txt", "a");
				pLogEuroc = fopen("pLogEuroc.txt", "a");

				// time stamp
				fprintf(pLogEuroc, "Here the timestamp, ");

				// gyro
				fprintf(pLogTot, "gyro x; %f, y: %f, z: %f   ", imuData.gyro.x(), imuData.gyro.y(), imuData.gyro.z());
				fprintf(pLogEuroc, "%f, %f, %f, ", imuData.gyro.x(), imuData.gyro.y(), imuData.gyro.z());
				//printf("gyro x; %f, y: %f, z: %f \n", imuData.gyro.x(), imuData.gyro.y(), imuData.gyro.z());

				// acceleration
				fprintf(pLogTot, "accel x; %f, y: %f, z: %f   ", imuData.accel.x(), imuData.accel.y(), imuData.accel.z());
				fprintf(pLogEuroc, "%f, %f, %f\n", imuData.accel.x(), imuData.accel.y(), imuData.accel.z());
				//printf("accel x; %f, y: %f, z: %f \n", imuData.accel.x(), imuData.accel.y(), imuData.accel.z());

				// compass
				fprintf(pLogTot, "compass x; %f, y: %f, z: %f   ", imuData.compass.x(), imuData.compass.y(), imuData.compass.z());
				//printf("compass x; %f, y: %f, z: %f \n", imuData.compass.x(), imuData.compass.y(), imuData.compass.z());

				// Pose
				fprintf(pLogTot, "pose x; %f, y: %f, z: %f\n", imuData.fusionPose.x(), imuData.fusionPose.y(), imuData.fusionPose.z());
				printf("pose x; %f, y: %f, z: %f \n", imuData.fusionPose.x(), imuData.fusionPose.y(), imuData.fusionPose.z());
				fclose(pLogTot);
				fclose(pLogEuroc);

				/*
				   typedef struct
				   {
				   uint64_t timestamp;
				   bool fusionPoseValid;
				   RTVector3 fusionPose;
				   bool fusionQPoseValid;
				   RTQuaternion fusionQPose;
				   bool gyroValid;
				   RTVector3 gyro;
				   bool accelValid;
				   RTVector3 accel;
				   bool compassValid;
				   RTVector3 compass;
				   bool pressureValid;
				   RTFLOAT pressure;
				   bool temperatureValid;
				   RTFLOAT temperature;
				   bool humidityValid;
				   RTFLOAT humidity;
				   } RTIMU_DATA;
				   */


				fflush(stdout);
				times->displayTimer = times->now;
			}

			//  update rate every second

			if ((times->now - times->rateTimer) > 1000000) {
				printf("sampleCount %d \n", times->sampleCount);
				times->sampleRate = times->sampleCount;
				times->sampleCount = 0;
				printf("now %llu \n", times->now);
				times->rateTimer = times->now;
			}
		}
	}

}


int main()
{

	// init the IMU
	RTIMU* imu = initIMU();

	// init the time monitor
	IMUtiming times = initIMUtiming();

	// process data
	recordIMUdata(imu, &times);

    
}

